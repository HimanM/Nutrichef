name: Deploy to VPS on push

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    name: SSH Deploy
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Run remote deploy commands over SSH
        uses: appleboy/ssh-action@v0.1.7
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          # You can supply either an SSH private key (VPS_SSH_KEY) or a password (VPS_SSH_PASSWORD).
          # If you don't have an SSH key, set the repository secret VPS_SSH_PASSWORD to your account password.
          key: ${{ secrets.VPS_SSH_KEY }}
          password: ${{ secrets.VPS_SSH_PASSWORD }}
          port: ${{ secrets.VPS_SSH_PORT }}
          # strict = false will skip host-key checking; safer to add the host key to a secret and set strict = true
          strict: false
          script: |
            set -e

            # Path on the VPS where the repo lives. Provide this as a repository secret named VPS_DEPLOY_PATH
            # Example secret value: /home/ubuntu/nutrichef
            DEPLOY_PATH="${{ secrets.VPS_DEPLOY_PATH }}"

            # tmux session name to target. Provide as VPS_TMUX_SESSION secret if different. Defaults to 'nutrichef'.
            TMUX_SESSION="${{ secrets.VPS_TMUX_SESSION }}"
            if [ -z "$TMUX_SESSION" ]; then
              TMUX_SESSION="nutrichef"
            fi

            # Switch to repo directory
            if [ ! -d "$DEPLOY_PATH" ]; then
              echo "Deploy path $DEPLOY_PATH does not exist. Exiting."
              exit 1
            fi
            cd "$DEPLOY_PATH"

            # Update repository to latest main
            cd "$DEPLOY_PATH"
            git fetch --all --prune
            git reset --hard origin/main

            # Create or overwrite backend/.env from repository secrets supplied to Actions.
            # The here-doc uses a quoted delimiter so the remote shell does not perform additional expansion.
            ENV_FILE="$DEPLOY_PATH/backend/.env"
            mkdir -p "$(dirname "$ENV_FILE")"
            # Use single-line printf calls to write the file (safer inside YAML block).
            printf '%s\n' "MAIL_SERVER = \"${{ secrets.MAIL_SERVER }}\"" > "$ENV_FILE"
            printf '%s\n' "MAIL_USERNAME = \"${{ secrets.MAIL_USERNAME }}\"" >> "$ENV_FILE"
            printf '%s\n' "MAIL_PASSWORD = \"${{ secrets.MAIL_PASSWORD }}\"" >> "$ENV_FILE"
            printf '%s\n' "MAIL_DEFAULT_SENDER = \"${{ secrets.MAIL_DEFAULT_SENDER }}\"" >> "$ENV_FILE"
            printf '%s\n' "GEMINI_API_KEY=\"${{ secrets.GEMINI_API_KEY }}\"" >> "$ENV_FILE"
            printf '%s\n' "PROJECT_NUMBER = \"${{ secrets.PROJECT_NUMBER }}\"" >> "$ENV_FILE"
            printf '%s\n' "FRONTEND_URL='${{ secrets.FRONTEND_URL }}'" >> "$ENV_FILE"
            printf '%s\n' "DOMAIN_URL='${{ secrets.DOMAIN_URL }}'" >> "$ENV_FILE"

            # Try docker compose v2 first (docker compose), fall back to docker-compose
            if command -v docker > /dev/null 2>&1; then
              DOCKER_CMD="docker compose pull || true && docker compose up -d --build"
            elif command -v docker-compose > /dev/null 2>&1; then
              DOCKER_CMD="docker-compose pull || true && docker-compose up -d --build"
            else
              echo "Neither 'docker' nor 'docker-compose' found on the server."
              exit 1
            fi

            # If the tmux session exists, send the docker restart command into it; otherwise run directly.
            if tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
              echo "Found tmux session '$TMUX_SESSION' — sending docker restart command into it."
              tmux send-keys -t "$TMUX_SESSION" "cd \"$DEPLOY_PATH\" && $DOCKER_CMD" C-m
            else
              echo "No tmux session named '$TMUX_SESSION' found — running docker restart directly."
              eval "cd \"$DEPLOY_PATH\" && $DOCKER_CMD"
            fi

            echo "Deployment finished."
